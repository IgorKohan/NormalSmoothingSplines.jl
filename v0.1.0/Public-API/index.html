<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · NormalSmoothingSplines.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">NormalSmoothingSplines.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#API-Summary"><span>API Summary</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../Usage/">Example Usage</a></li><li><a class="tocitem" href="../Normal-Splines-Method/">Normal Splines Method</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/master/docs/src/Public-API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h1><h2 id="API-Summary"><a class="docs-heading-anchor" href="#API-Summary">API Summary</a><a id="API-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#API-Summary" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>prepare_approximation</code></td><td style="text-align: left">Prepare the smoothing spline by constructing and factoring a Gram matrix of the problem.</td></tr><tr><td style="text-align: left"><code>construct_approximation</code></td><td style="text-align: left">Construct the smoothing spline by calculating its coefficients.</td></tr><tr><td style="text-align: left"><code>approximate</code></td><td style="text-align: left">Prepare and construct the smoothing spline.</td></tr><tr><td style="text-align: left"><code>prepare_interpolation</code></td><td style="text-align: left">Prepare the interpolating spline by constructing and factoring a Gram matrix of the problem.</td></tr><tr><td style="text-align: left"><code>construct_interpolation</code></td><td style="text-align: left">Construct the interpolating spline by calculating its coefficients.</td></tr><tr><td style="text-align: left"><code>interpolate</code></td><td style="text-align: left">Prepare and construct the interpolating spline.</td></tr><tr><td style="text-align: left"><code>evaluate</code></td><td style="text-align: left">Evaluate the spline values.</td></tr><tr><td style="text-align: left"><code>evaluate_at</code></td><td style="text-align: left">Evaluate the spline value at the required location.</td></tr><tr><td style="text-align: left"><code>evaluate_gradient</code></td><td style="text-align: left">Evaluate gradient of the spline at the required location.</td></tr><tr><td style="text-align: left"><code>evaluate_derivative</code></td><td style="text-align: left">Evaluate the 1-D spline derivative at the required location.</td></tr><tr><td style="text-align: left"><code>estimate_accuracy</code></td><td style="text-align: left">Estimate accuracy of the function interpolation result.</td></tr><tr><td style="text-align: left"><code>estimate_cond</code></td><td style="text-align: left">Estimate the Gram matrix 1-norm condition number.</td></tr><tr><td style="text-align: left"><code>estimate_epsilon</code></td><td style="text-align: left">Estimate the &#39;scaling parameter&#39; of Bessel potential space the spline being built in.</td></tr><tr><td style="text-align: left"><code>get_epsilon</code></td><td style="text-align: left">Get the &#39;scaling parameter&#39; of Bessel potential space the normal spline was built in.</td></tr><tr><td style="text-align: left"><code>get_cond</code></td><td style="text-align: left">Get the Gram matrix spectral condition number.</td></tr></table><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.prepare_approximation" href="#NormalSmoothingSplines.prepare_approximation"><code>NormalSmoothingSplines.prepare_approximation</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>prepare_approximation(nodes_b::Matrix{T}, kernel::RK = RK_H0())                        where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare the approximating normal spline by constructing and factoring a Gram matrix of the problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes_b</code>: function value approximation nodes.         This should be an <code>n×n_1_b</code> matrix, where <code>n</code> is dimension of the sampled space and         <code>n_1_b</code> is the number of function value approximation nodes. It means that each column in the matrix defines one node.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: prepared <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L91-L108">source</a></section><section><div><p><code>prepare_approximation(nodes::Matrix{T}, nodes_b::Matrix{T}, kernel::RK = RK_H0())                        where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare the approximating normal spline by constructing and factoring a Gram matrix of the problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_1</code> is the number of function value interpolation nodes. It means that each column in the matrix defines one node.</li><li><code>nodes_b</code>: function value approximation nodes.         This should be an <code>n×n_1_b</code> matrix, where <code>n</code> is dimension of the sampled space and         <code>n_1_b</code> is the number of function value approximation nodes. It means that each column in the matrix defines one node.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: prepared <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L116-L136">source</a></section><section><div><p><code>prepare_approximation(nodes_b::Vector{T}, kernel::RK = RK_H0())                        where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare the 1D approximating normal spline by constructing and factoring a Gram matrix of the problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes_b</code>: function value approximation nodes.            This should be an <code>n_1_b</code> vector where <code>n_1_b</code> is the number of function value approximation nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: prepared <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L427-L443">source</a></section><section><div><p><code>prepare_approximation(nodes::Vector{T}, nodes_b::Vector{T}, kernel::RK = RK_H0())                        where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare the 1D approximating normal spline by constructing and factoring a Gram matrix of the problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n_1</code> vector where <code>n_1</code> is the number of function value interpolation nodes.</li><li><code>nodes_b</code>: function value approximation nodes.          This should be an <code>n_1_b</code> vector where <code>n_1_b</code> is the number of function value approximation nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: prepared <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L452-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.construct_approximation" href="#NormalSmoothingSplines.construct_approximation"><code>NormalSmoothingSplines.construct_approximation</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>construct_approximation(spline::NormalSpline{T, RK},                          values_lb::Vector{T}, values_ub::Vector{T},                          maxiter::Int, ftol::T)                          where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>construct the approximating normal spline by calculating its coefficients and completely initializing the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the partly initialized <code>NormalSpline</code> object returned by <code>prepare</code> function.</li><li><code>values_lb</code>: function lower bound values at approximation nodes</li><li><code>values_ub</code>: function upper bound values at approximation nodes</li><li><code>maxiter</code>: Maximum allowed number of iterations.</li><li><code>ftol</code>: convergence tolerance. The iteration stops when relative spline norm change is smaller than ftol.</li></ul><p>Return: constructed <code>NormalSpline</code> object and the number of QP algorithm iterations done.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L145-L161">source</a></section><section><div><p><code>construct_approximation(spline::NormalSpline{T, RK}, values::Vector{T},                          values_lb::Vector{T}, values_ub::Vector{T}, maxiter::Int, ftol::T)                          where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>construct the approximating normal spline by calculating its coefficients and completely initializing the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the partly initialized <code>NormalSpline</code> object returned by <code>prepare</code> function.</li><li><code>values</code>: function values at interpolation nodes.</li><li><code>values_lb</code>: function lower bound values at approximation nodes</li><li><code>values_ub</code>: function upper bound values at approximation nodes</li><li><code>maxiter</code>: Maximum allowed number of iterations.</li><li><code>ftol</code>: convergence tolerance. The iteration stops when relative spline norm change is smaller than ftol.</li></ul><p>Return: constructed <code>NormalSpline</code> object and the number of QP algorithm iterations done.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L172-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.approximate" href="#NormalSmoothingSplines.approximate"><code>NormalSmoothingSplines.approximate</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>approximate(nodes::Matrix{T}, values::Vector{T}, nodes_b::Matrix{T}, values_lb::Vector{T}, values_ub::Vector{T},              kernel::RK, maxiter::Int, ftol::T) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare and construct the approximating normal spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes_b</code>: function value approximation nodes.       This should be an <code>n×n_1_b</code> matrix, where <code>n</code> is dimension of the sampled space and       <code>n_1_b</code> is the number of function value approximation nodes. It means that each column in the matrix defines one node.</li><li><code>values_lb</code>: function lower bound values at approximation nodes</li><li><code>values_ub</code>: function upper bound values at approximation nodes</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li><li><code>maxiter</code>: Maximum allowed number of iterations.</li><li><code>ftol</code>: convergence tolerance. The iteration stops when relative spline norm change is smaller than ftol.</li></ul><p>Return: constructed <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L200-L220">source</a></section><section><div><p><code>approximate(nodes::Matrix{T}, values::Vector{T}, nodes_b::Matrix{T}, values_lb::Vector{T}, values_ub::Vector{T},              kernel::RK, maxiter::Int, ftol::T) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare and construct the approximating normal spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li><li><code>nodes_b</code>: function value approximation nodes.       This should be an <code>n×n_1_b</code> matrix, where <code>n</code> is dimension of the sampled space and       <code>n_1_b</code> is the number of function value approximation nodes. It means that each column in the matrix defines one node.</li><li><code>values</code>: function values at interpolation nodes.</li><li><code>values_lb</code>: function lower bound values at approximation nodes</li><li><code>values_ub</code>: function upper bound values at approximation nodes</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li><li><code>maxiter</code>: Maximum allowed number of iterations.</li><li><code>ftol</code>: convergence tolerance. The iteration stops when relative spline norm change is smaller than ftol.</li></ul><p>Return: constructed <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L233-L258">source</a></section><section><div><p><code>approximate(values::Vector{T}, nodes_b::Vector{T}, values_lb::Vector{T}, values_ub::Vector{T},              kernel::RK, maxiter::Int, ftol::T) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare and construct the 1D approximating normal spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes_b</code>: function value approximation nodes.         This should be an <code>n_1_b</code> vector where <code>n_1_b</code> is the number of function value approximation nodes.</li><li><code>values_lb</code>: function lower bound values at approximation nodes</li><li><code>values_ub</code>: function upper bound values at approximation nodes</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li><li><code>maxiter</code>: Maximum allowed number of iterations.</li><li><code>ftol</code>: convergence tolerance. The iteration stops when relative spline norm change is smaller than ftol.</li></ul><p>Return: constructed <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L479-L498">source</a></section><section><div><p><code>approximate(nodes::Vector{T}, values::Vector{T}, nodes_b::Vector{T}, values_lb::Vector{T}, values_ub::Vector{T},              kernel::RK, maxiter::Int, ftol::T) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare and construct the 1D approximating normal spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.         This should be an <code>n_1</code> vector where <code>n_1</code> is the number of function value interpolation nodes.</li><li><code>values</code>: function values at interpolation nodes.</li><li><code>nodes_b</code>: function value approximation nodes.         This should be an <code>n_1_b</code> vector where <code>n_1_b</code> is the number of function value approximation nodes.</li><li><code>values_lb</code>: function lower bound values at approximation nodes</li><li><code>values_ub</code>: function upper bound values at approximation nodes</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li><li><code>maxiter</code>: Maximum allowed number of iterations.</li><li><code>ftol</code>: convergence tolerance. The iteration stops when relative spline norm change is smaller than ftol.</li></ul><p>Return: constructed <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L511-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.prepare_interpolation" href="#NormalSmoothingSplines.prepare_interpolation"><code>NormalSmoothingSplines.prepare_interpolation</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>prepare_interpolation(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare the interpolating normal spline by constructing and factoring Gram matrix of the problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_1</code> is the number of function value nodes. It means that each column in the matrix defines one node.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: prepared <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalInterpolatingSplines.jl#L1-L17">source</a></section><section><div><p><code>prepare_interpolation(nodes::Matrix{T}, d_nodes::Matrix{T}, es::Matrix{T}, kernel::RK = RK_H1())                        where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Prepare the spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_1</code> is the number of function value nodes.           It means that each column in the matrix defines one node.</li><li><code>d_nodes</code>: function directional derivatives nodes.            This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and            <code>n_2</code> is the number of function directional derivative nodes.</li><li><code>es</code>: Directions of the function directional derivatives.       This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and       <code>n_2</code> is the number of function directional derivative nodes.       It means that each column in the matrix defines one direction of the function directional derivative.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: prepared <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalInterpolatingSplines.jl#L71-L95">source</a></section><section><div><p><code>prepare_interpolation(nodes::Vector{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare the 1D interpolating normal spline by constructing and factoring a Gram matrix of the problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n_1</code> vector where <code>n_1</code> is the number of function value nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: prepared <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalInterpolatingSplines.jl#L166-L181">source</a></section><section><div><p><code>prepare_interpolation(nodes::Vector{T}, d_nodes::Vector{T}, kernel::RK = RK_H1()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Prepare the 1D interpolating normal spline by constructing and factoring a Gram matrix of the problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n_1</code> vector where <code>n_1</code> is the number of function value nodes.</li><li><code>d_nodes</code>: The function derivatives nodes.            This should be an <code>n_2</code> vector where <code>n_2</code> is the number of function derivatives nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: prepared <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalInterpolatingSplines.jl#L214-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.construct_interpolation" href="#NormalSmoothingSplines.construct_interpolation"><code>NormalSmoothingSplines.construct_interpolation</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>construct_interpolation(spline::NormalSpline{T, RK}, values::Vector{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Construct the interpolating normal spline by calculating its coefficients and completely initializing the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the prepared <code>NormalSpline</code> object.</li><li><code>values</code>: function values at interpolation nodes.</li></ul><p>Return: constructed <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalInterpolatingSplines.jl#L25-L35">source</a></section><section><div><p><code>construct_interpolation(spline::NormalSpline{T, RK}, values::Vector{T}, d_values::Vector{T})                          where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Construct the interpolating normal spline by calculating its coefficients and completely initializing the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the prepared <code>NormalSpline</code> object.</li><li><code>values</code>: function values at interpolation nodes.</li><li><code>d_values</code>: function directional derivative values at function derivative nodes.</li></ul><p>Return: constructed <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalInterpolatingSplines.jl#L105-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.interpolate" href="#NormalSmoothingSplines.interpolate"><code>NormalSmoothingSplines.interpolate</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>interpolate(nodes::Matrix{T}, values::Vector{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare and construct the interpolating normal spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li><li><code>values</code>: function values at interpolation nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: constructed <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalInterpolatingSplines.jl#L43-L59">source</a></section><section><div><p><code>interpolate(nodes::Matrix{T}, values::Vector{T}, d_nodes::Matrix{T}, es::Matrix{T}, d_values::Vector{T}, kernel::RK = RK_H1())              where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Prepare and construct the interpolating normal spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li><li><code>values</code>: function values at interpolation nodes.</li><li><code>d_nodes</code>: function directional derivative nodes.           This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and           <code>n_2</code> is the number of function directional derivative nodes.</li><li><code>es</code>: Directions of the function directional derivatives.      This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and      <code>n_2</code> is the number of function directional derivative nodes.      It means that each column in the matrix defines one direction of the function directional derivative.</li><li><code>d_values</code>: function directional derivative values at function derivative nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: constructed <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalInterpolatingSplines.jl#L126-L151">source</a></section><section><div><p><code>interpolate(nodes::Vector{T}, values::Vector{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare and construct the 1D interpolating normal spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n_1</code> vector where <code>n_1</code> is the number of function value nodes.</li><li><code>values</code>: function values at <code>n_1</code> interpolation nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: constructed <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalInterpolatingSplines.jl#L189-L204">source</a></section><section><div><p><code>interpolate(nodes::Vector{T}, values::Vector{T}, d_nodes::Vector{T}, d_values::Vector{T},              kernel::RK = RK_H1())              where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>prepare_interpolation and construct the 1D interpolating normal spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n_1</code> vector where <code>n_1</code> is the number of function value nodes.</li><li><code>values</code>: function values at <code>nodes</code> nodes.</li><li><code>d_nodes</code>: The function derivatives nodes.            This should be an <code>n_2</code> vector where <code>n_2</code> is the number of function derivatives nodes.</li><li><code>d_values</code>: function derivative values at function derivative nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: constructed <code>NormalSpline</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalInterpolatingSplines.jl#L241-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.evaluate" href="#NormalSmoothingSplines.evaluate"><code>NormalSmoothingSplines.evaluate</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>evaluate(spline::NormalSpline{T, RK}, points::Matrix{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the spline values at <code>points</code> locations.</p><p><strong>Arguments</strong></p><ul><li><code>spline: constructed</code>NormalSpline` object.</li><li><code>points</code>: locations at which spline values are evaluating.           This should be an <code>n×m</code> matrix, where <code>n</code> is dimension of the sampled space           and <code>m</code> is the number of locations where spline values are evaluating.           It means that each column in the matrix defines one location.</li></ul><p>Return: <code>Vector{T}</code> of the spline values at the locations defined in <code>points</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L273-L286">source</a></section><section><div><p><code>evaluate(spline::NormalSpline{T, RK}, points::Vector{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the 1D spline values at the <code>points</code> locations.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: constructed <code>NormalSpline</code> object.</li><li><code>points</code>: locations at which spline values are evaluating.           This should be a vector of size <code>m</code> where <code>m</code> is the number of evaluating points.</li></ul><p>Return: spline value at the <code>point</code> location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L548-L559">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.evaluate_at" href="#NormalSmoothingSplines.evaluate_at"><code>NormalSmoothingSplines.evaluate_at</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>evaluate_at(spline::NormalSpline{T, RK}, point::Vector{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the spline value at the <code>point</code> location.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: constructed <code>NormalSpline</code> object.</li><li><code>point</code>: location at which spline value is evaluating.          This should be a vector of size <code>n</code>, where <code>n</code> is dimension of the sampled space.</li></ul><p>Return: spline value at the location defined in <code>point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L292-L303">source</a></section><section><div><p><code>evaluate_at(spline::NormalSpline{T, RK}, point::T) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the 1D spline value at the <code>point</code> location.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: constructed <code>NormalSpline</code> object.</li><li><code>point</code>: location at which spline value is evaluating.</li></ul><p>Return: spline value at the <code>point</code> location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L565-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.evaluate_gradient" href="#NormalSmoothingSplines.evaluate_gradient"><code>NormalSmoothingSplines.evaluate_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>evaluate_gradient(spline::NormalSpline{T, RK}, point::Vector{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate gradient of the spline at the location defined in <code>point</code>.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>point</code>: location at which gradient value is evaluating.          This should be a vector of size <code>n</code>, where <code>n</code> is dimension of the sampled space.</li></ul><p>Note: Gradient of spline built with reproducing kernel RK_H0 does not exist at the spline nodes.</p><p>Return: <code>Vector{T}</code> - gradient of the spline at the <code>point</code> location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L309-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.evaluate_derivative" href="#NormalSmoothingSplines.evaluate_derivative"><code>NormalSmoothingSplines.evaluate_derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>evaluate_derivative(spline::NormalSpline{T, RK}, point::T) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the 1D spline derivative at the <code>point</code> location.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>point</code>: location at which spline derivative is evaluating.</li></ul><p>Note: Derivative of spline built with reproducing kernel RK_H0 does not exist at the spline nodes.</p><p>Return: spline derivative value at the <code>point</code> location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L584-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.estimate_accuracy" href="#NormalSmoothingSplines.estimate_accuracy"><code>NormalSmoothingSplines.estimate_accuracy</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>estimate_accuracy(spline::NormalSpline{T, RK}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Assess accuracy of interpolation results by analyzing residuals.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: constructed <code>NormalSpline</code> object.</li></ul><p>Return: estimation of the number of significant digits in the interpolation result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L412-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.estimate_cond" href="#NormalSmoothingSplines.estimate_cond"><code>NormalSmoothingSplines.estimate_cond</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>estimate_cond(spline::NormalSpline{T, RK}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Get an estimation of the Gram matrix condition number. It needs the <code>spline</code> object is prepared and requires O(N^2) operations. (C. Brás, W. Hager, J. Júdice, An investigation of feasible descent algorithms for estimating the condition number of a matrix. TOP Vol.20, No.3, 2012.)</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: prepared <code>NormalSpline</code> object.</li></ul><p>Return: an estimation of the Gram matrix condition number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L397-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.get_epsilon" href="#NormalSmoothingSplines.get_epsilon"><code>NormalSmoothingSplines.get_epsilon</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>get_epsilon(spline::NormalSpline{T, RK}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Get the &#39;scaling parameter&#39; of Bessel Potential space the spline was built in.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: prepared <code>NormalSpline</code> object.</li></ul><p>Return: <code>ε</code> - the &#39;scaling parameter&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L331-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.estimate_epsilon" href="#NormalSmoothingSplines.estimate_epsilon"><code>NormalSmoothingSplines.estimate_epsilon</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>estimate_epsilon(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Get the estimation of the &#39;scaling parameter&#39;2 of Bessel Potential space the spline being built in. It coincides with the result returned by <code>get_epsilon</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline will be constructed in.          It must be a struct object of the following type:            <code>RK_H0</code> if the spline is constructing as a continuous function,            <code>RK_H1</code> if the spline is constructing as a differentiable function,            <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: estimation of <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L345-L361">source</a></section><section><div><p><code>estimate_epsilon(nodes::Matrix{T}, d_nodes::Matrix{T}, kernel::RK = RK_H1()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Get an the estimation of the &#39;scaling parameter&#39; of Bessel Potential space the spline being built in. It coincides with the result returned by <code>get_epsilon</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li><li><code>d_nodes</code>: function directional derivative nodes.          This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_2</code> is the number of function directional derivative nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline will be constructed in.           It must be a struct object of the following type:           <code>RK_H1</code> if the spline is constructing as a differentiable function,           <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: estimation of <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L369-L388">source</a></section><section><div><p><code>estimate_epsilon(nodes::Vector{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Get an the estimation of the &#39;scaling parameter&#39; of Bessel Potential space the spline being built in. It coincides with the result returned by <code>get_epsilon</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: estimation of <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L605-L619">source</a></section><section><div><p><code>estimate_epsilon(nodes::Vector{T}, d_nodes::Vector{T}, kernel::RK = RK_H1()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Get an the estimation of the &#39;scaling parameter&#39; of Bessel Potential space the spline being built in. It coincides with the result returned by <code>get_epsilon</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.</li><li><code>d_nodes</code>: function derivative nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: estimation of <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L627-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.get_cond" href="#NormalSmoothingSplines.get_cond"><code>NormalSmoothingSplines.get_cond</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>get_cond(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Get a value of the Gram matrix spectral condition number. It is obtained by means of the matrix SVD decomposition.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_1</code> is the number of function value nodes. It means that each column in the matrix defines one node.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: a value of the Gram matrix spectral condition number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L650-L665">source</a></section><section><div><p><code>get_cond(nodes::Matrix{T}, d_nodes::Matrix{T}, es::Matrix{T}, kernel::RK = RK_H1()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Get a value of the Gram matrix spectral condition number. It is obtained by means of the matrix SVD decomposition.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: function value interpolation nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_1</code> is the number of function value nodes.           It means that each column in the matrix defines one node.</li><li><code>d_nodes</code>: function directional derivatives nodes.            This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and            <code>n_2</code> is the number of function directional derivative nodes.</li><li><code>es</code>: Directions of the function directional derivatives.       This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and       <code>n_2</code> is the number of function directional derivative nodes.       It means that each column in the matrix defines one direction of the function directional derivative.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: value of the Gram matrix spectral condition number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L670-L692">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><h3 id="Bessel-potential-Space-Reproducing-Kernels"><a class="docs-heading-anchor" href="#Bessel-potential-Space-Reproducing-Kernels">Bessel potential Space Reproducing Kernels</a><a id="Bessel-potential-Space-Reproducing-Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Bessel-potential-Space-Reproducing-Kernels" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.RK_H0" href="#NormalSmoothingSplines.RK_H0"><code>NormalSmoothingSplines.RK_H0</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct RK_H0{T &lt;: AbstractFloat} &lt;: ReproducingKernel_0</code></p><p>Defines a type of reproducing kernel of Bessel Potential space <span>$H^{n/2 + 1/2}_ε (R^n)$</span> (&#39;Basic Matérn kernel&#39;):</p><div>\[V(\eta , \xi, \varepsilon) = \exp (-\varepsilon |\xi - \eta|) \, .\]</div><p><strong>Fields</strong></p><ul><li><code>ε::T</code>: &#39;scaling parameter&#39; from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/ReproducingKernels.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.RK_H1" href="#NormalSmoothingSplines.RK_H1"><code>NormalSmoothingSplines.RK_H1</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct RK_H1{T &lt;: AbstractFloat} &lt;: ReproducingKernel_1</code></p><p>Defines a type of reproducing kernel of Bessel Potential space <span>$H^{n/2 + 3/2}_ε (R^n)$</span> (&#39;Linear Matérn kernel&#39;):</p><div>\[V(\eta , \xi, \varepsilon) = \exp (-\varepsilon |\xi - \eta|)
             (1 + \varepsilon |\xi  - \eta|) \, .\]</div><p><strong>Fields</strong></p><ul><li><code>ε::T</code>: &#39;scaling parameter&#39; from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/ReproducingKernels.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.RK_H2" href="#NormalSmoothingSplines.RK_H2"><code>NormalSmoothingSplines.RK_H2</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct RK_H2{T &lt;: AbstractFloat} &lt;: ReproducingKernel_2</code></p><p>Defines a type of reproducing kernel of Bessel Potential space <span>$H^{n/2 + 5/2}_ε (R^n)$</span> (&#39;Quadratic Matérn kernel&#39;):</p><div>\[V(\eta , \xi, \varepsilon) = \exp (-\varepsilon |\xi - \eta|)
             (3 + 3\varepsilon |\xi  - \eta| + \varepsilon ^2 |\xi - \eta| ^2 ) \, .\]</div><p><strong>Fields</strong></p><ul><li><code>ε::T</code>: &#39;scaling parameter&#39; from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/ReproducingKernels.jl#L58-L70">source</a></section></article><h3 id="NormalSpline-structure"><a class="docs-heading-anchor" href="#NormalSpline-structure">NormalSpline structure</a><a id="NormalSpline-structure-1"></a><a class="docs-heading-anchor-permalink" href="#NormalSpline-structure" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NormalSmoothingSplines.NormalSpline" href="#NormalSmoothingSplines.NormalSpline"><code>NormalSmoothingSplines.NormalSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct NormalSpline{T, RK} &lt;: AbstractSpline where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Define a structure containing full information of a normal spline</p><p><strong>Fields</strong></p><ul><li><code>_kernel</code>: a reproducing kernel spline was built with</li><li><code>_compression</code>: factor of transforming the original node locations into unit hypercube</li><li><code>_nodes</code>: transformed function value interpolation nodes</li><li><code>_nodes_b</code>: transformed function value approximation nodes</li><li><code>_values</code>: function values at interpolation nodes</li><li><code>_values_lb</code>: function lower bound values at approximation nodes</li><li><code>_values_ub</code>: function upper bound values at approximation nodes</li><li><code>_d_nodes</code>: transformed function directional derivative interpolation nodes</li><li><code>_d_nodes_b</code>: transformed function directional derivative approximation nodes</li><li><code>_es</code>: normalized derivative directions at interpolation nodes</li><li><code>_es_b</code>: normalized derivative directions at approximation nodes</li><li><code>_d_values</code>: function directional derivative values at interpolation nodes</li><li><code>_d_values_lb</code>: function lower bound directional derivative values at approximation nodes</li><li><code>_d_values_ub</code>: function upper bound directional derivative values at approximation nodes</li><li><code>_min_bound</code>: minimal bounds of the original node locations area</li><li><code>_gram</code>: Gram matrix of the problem</li><li><code>_chol</code>: Cholesky factorization of the Gram matrix</li><li><code>_mu</code>: spline coefficients</li><li><code>_active</code>: active inequality constraint numbers at solution</li><li><code>_cond</code>: estimation of the Gram matrix condition number</li><li><code>_ier</code>: An integer flag. If it is equal to 0, the optimal solution was found.         If it is equal to 1, the approximate solution was found. QP algorithm iterations were stopped         because of small spline norm change.         If it is equal to 2, the approximate solution was found. QP algorithm iterations were stopped         because of maximum allowed number of iterations was reached.         If it is equal to -1, the solution was not calculated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalSmoothingSplines.jl/blob/9ee91cdd734f0711ce4bbeb6cc8ad5a81c18e229/src/NormalSmoothingSplines.jl#L23-L54">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#NormalSmoothingSplines.approximate"><code>NormalSmoothingSplines.approximate</code></a></li><li><a href="#NormalSmoothingSplines.construct_approximation"><code>NormalSmoothingSplines.construct_approximation</code></a></li><li><a href="#NormalSmoothingSplines.construct_interpolation"><code>NormalSmoothingSplines.construct_interpolation</code></a></li><li><a href="#NormalSmoothingSplines.estimate_accuracy"><code>NormalSmoothingSplines.estimate_accuracy</code></a></li><li><a href="#NormalSmoothingSplines.estimate_cond"><code>NormalSmoothingSplines.estimate_cond</code></a></li><li><a href="#NormalSmoothingSplines.estimate_epsilon"><code>NormalSmoothingSplines.estimate_epsilon</code></a></li><li><a href="#NormalSmoothingSplines.evaluate"><code>NormalSmoothingSplines.evaluate</code></a></li><li><a href="#NormalSmoothingSplines.evaluate_at"><code>NormalSmoothingSplines.evaluate_at</code></a></li><li><a href="#NormalSmoothingSplines.evaluate_derivative"><code>NormalSmoothingSplines.evaluate_derivative</code></a></li><li><a href="#NormalSmoothingSplines.evaluate_gradient"><code>NormalSmoothingSplines.evaluate_gradient</code></a></li><li><a href="#NormalSmoothingSplines.get_cond"><code>NormalSmoothingSplines.get_cond</code></a></li><li><a href="#NormalSmoothingSplines.get_epsilon"><code>NormalSmoothingSplines.get_epsilon</code></a></li><li><a href="#NormalSmoothingSplines.interpolate"><code>NormalSmoothingSplines.interpolate</code></a></li><li><a href="#NormalSmoothingSplines.prepare_approximation"><code>NormalSmoothingSplines.prepare_approximation</code></a></li><li><a href="#NormalSmoothingSplines.prepare_interpolation"><code>NormalSmoothingSplines.prepare_interpolation</code></a></li><li><a href="#NormalSmoothingSplines.NormalSpline"><code>NormalSmoothingSplines.NormalSpline</code></a></li><li><a href="#NormalSmoothingSplines.RK_H0"><code>NormalSmoothingSplines.RK_H0</code></a></li><li><a href="#NormalSmoothingSplines.RK_H1"><code>NormalSmoothingSplines.RK_H1</code></a></li><li><a href="#NormalSmoothingSplines.RK_H2"><code>NormalSmoothingSplines.RK_H2</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../Usage/">Example Usage »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 9 May 2021 06:25">Sunday 9 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
